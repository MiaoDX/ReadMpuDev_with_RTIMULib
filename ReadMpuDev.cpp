#include "ReadMpuDev.h"


//class mpuDev

int mpuDev::mpuDevInit(){
	//  Using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
	//  Or, you can create the .ini in some other directory by using:
	//      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
	//  where <directory path> is the path to where the .ini file is to be loaded/saved

	settings = new RTIMUSettings("RTIMULib");

	imu = RTIMU::createIMU(settings);

	if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)) {
		printf("No IMU found\n");
		return -1;
	}

	//  This is an opportunity to manually override any settings before the call IMUInit

	//  set up IMU

	if (!imu->IMUInit()) { //失败
		cerr << "init imu failed" << endl;
		return -2;
	}

	//  this is a convenient place to change fusion parameters

	imu->setSlerpPower(0.02);
	imu->setGyroEnable(true);
	imu->setAccelEnable(true);
	imu->setCompassEnable(true);
	return 0;
}


void mpuDev::mpuDevReadForever(){
	int sampleCount = 0;
	int sampleRate = 0;
	uint64_t rateTimer;
	uint64_t displayTimer;
	uint64_t now;

	//  set up for rate timer

	rateTimer = displayTimer = RTMath::currentUSecsSinceEpoch();


	//  now just process data

	while (true) {
		//  poll at the rate recommended by the IMU

		usleep(imu->IMUGetPollInterval() * 1000);	//mpuDev 建议是 4ms 取一次数据，也就是 250 次每秒，我们的程序要求每秒钟 100 个数据是可以达到的

		while (imu->IMURead()) {
			RTIMU_DATA imuData = imu->getIMUData();
			sampleCount++;

			now = RTMath::currentUSecsSinceEpoch();

			//  update 400 times per second 也就是间隔 2.5*1000 us 读一次

			if ((now - displayTimer) > 2500) {
				//printf("Sample rate %d: %s\r", sampleRate, RTMath::displayDegrees("", imuData.fusionPose));
				//cout << imuData.fusionPose.z() * RTMATH_RAD_TO_DEGREE << endl;
				//fflush(stdout);

				mpuAngle.mpuDevAngleBufferUpdate(RTVector3_T<RTFLOAT>(imuData.fusionPose.x() * RTMATH_RAD_TO_DEGREE, imuData.fusionPose.y() * RTMATH_RAD_TO_DEGREE, imuData.fusionPose.z() * RTMATH_RAD_TO_DEGREE));

				displayTimer = now;
			}

			//  update rate every second

			if ((now - rateTimer) > 1000000) {
				sampleRate = sampleCount;
				sampleCount = 0;
				rateTimer = now;
			}
		}
	}
}


void mpuDev::mpuDevrun(){	//开启轮询，将其 detach 以保证会不停更新 fifo，且可以继续进行其他操作
	std::thread t2(&mpuDev::mpuDevReadForever, this);
	t2.detach();
}



//class mpuDevAngle
int mpuDevAngle::mpuDevAngleInit(int _bufferSize /*= 20*/) {
	bufferSize = _bufferSize;
	mpubuffer.resize(bufferSize);
	return 0;
}

void mpuDevAngle::mpuDevAngleBufferUpdate(RTVector3_T<RTFLOAT> newAngle) {
	lock_guard<mutex> lock(accessBufferMutex);
	mpubuffer.pop_front();
	mpubuffer.push_back(newAngle);

}
;

inline RTVector3_T<RTFLOAT> mpuDevAngle::CalculateAvg(list<RTVector3_T<RTFLOAT>> &callist)
{
	RTVector3_T<RTFLOAT> avg(0,0,0);
	list<RTVector3_T<RTFLOAT>>::iterator it;
	for (it = callist.begin(); it != callist.end(); it++) {
		avg += *it;
		//cout << " " << *it ;
	}

	avg.setX(avg.x() / callist.size());
	avg.setY(avg.y() / callist.size());
	avg.setZ(avg.z() / callist.size());
	return avg;
}

//当前值:按 yaw 进行排序， sort(CompZ())
int mpuDevAngle::mpuDevAnglePresentUpdate() {
	lock_guard<mutex> lock(accessBufferMutex);
	presentAngle = CalculateAvg(mpubuffer);
	return 0;
}

RTVector3_T<RTFLOAT> mpuDevAngle::getAnglePresent() {
	return presentAngle;
}
